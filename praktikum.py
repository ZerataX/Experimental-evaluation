import os.path
import csv
import numpy as np

def get_parameter(path, value):
    """
    retrieves a value found in files generated by gnuplot using the
    'update <filename>' function
    :param path:    filepath as a string
    :param value:   the name of value that should be searched for as a string
    :return:        the value itself as a float
    """
    if os.path.isfile(path):
        with open(path) as f:
            for line in f:
                if not line.startswith("#") and not "," in line:
                    line = line.split("=")
                    if value == line[0].strip():
                        return float(line[1].split("#", 1)[0].strip())
        print("Value does not exist")
    else:
        print("File does not exist")

def create_tex_table(*arg):
    """
    Creates a latex table out of python arrays

    array2tex.create_tex_table( ( array, error, position), ... )

    Example:

    A = [0.03, 0.05, 0.07]

    B = [0.007, 0.011, 0.015]
    B_err = [0.0014, 0.0008, 0.0011]

    C = [0.1,0.01,0.001]
    C_err = [0.05,0.005,0.0005]
    C_pos = [2,3,4]

    print(array2tex.create_tex_table( (A), (B, B_err, 4), (C, C_err, C_pos)))
    returns:

    \begin{tabular}
    ROW & ROW & ROW\\
    \hline
    0.03 & \SI{0.0070(14)}{} & \SI{0.10(5)} \\
    0.05 & \SI{0.0110(8)}{} & \SI{0.010(5)} \\
    0.07 & \SI{0.0150(11)}{} & \SI{0.0010(5)} \\
    \end{tabular}
    :param *arg:    array of numbers
    :return:        string of table in latex format
    """

    table = "\\begin{tabular}\n"

    for rows in arg:
        table += "ROW & "

    table = table[:-3] + "\\\\\n\\hline\n"

    if type(arg[0]) is list:
        lines = len(arg[0])
    else:
        lines = len(arg[0][0])

    for index in range(lines):
        for rows in arg:
            if type(rows) is list:
                table += "{} & ".format(rows[index])
            else:
                values = rows[0]
                uncertainties = rows[1]
                positions = rows[2]
                if type(uncertainties) is float or type(uncertainties) is int:
                    uncertainty = uncertainties
                else:
                    uncertainty = uncertainties[index]
                if type(positions) is float or type(positions) is int:
                    position = positions
                else:
                    position = positions[index]
                value = values[index]

                table += "{} & ".format(add_uncertainty(value, uncertainty, position))

        table = table[:-3] + "\\\\\n"
    table += "\n\\end{tabular}"
    return table

def add_uncertainty(value, uncertainty, position):
    """
    Adds uncertainty to a value in the format used by the SI Latex package.
    Eg: \SI{0.0150(11)}{}
    :param value:
    :param uncertainty:
    :param position:    desired decimals as an integer
    :return: string of value + uncertainty in SI format
    """
    value = round(value, position)
    value = str(value).ljust(position+2,'0')
    uncertainty = round(uncertainty*10**position)
    result = "\\SI{{{}({})}}{{}}".format(value, uncertainty)
    return result

def fix_data_studio(dir):
    """
    Converts a Data Studio File to csv.
    Current directory:
    dir = os.path.dirname(os.path.realpath(__file__))
    Eg:
    Position, Messreihe #11
    Zeit ( s )	Position ( m )
    0,0011	0,393
    0,1011	0,385
    0,2011	0,379
    0,3011	0,376

    to

    0.0011,0.393
    0.1011,0.385
    0.2011,0.379
    0.3011,0.376
    :param dir: the directory with the files
    """
    for root, dirs, files in os.walk(dir):
        for file in files:
            if file.endswith(".txt"):
                f1 = open(os.path.join(root, file), 'r')
                f2 = open(os.path.join(root, file) + '_fixed', 'w')
                for line in f1:
                    f2.write(line.replace(",",".").replace("\t",","))
                f1.close()
                f2.close()
                lines = open(os.path.join(root, file) + '_fixed').readlines()
                open(os.path.join(root, file) + '_fixed', 'w').writelines(lines[2:])

def export_csv(filename, *arg, precison=2):
    """
    Exportiert Arrays als .csv Datei
    :param *arg: Array of integers
    :param filename: Name der Datei, in welche gespeichert wird.
    :param precison: Anzahl der Nachkommastellen, nach denen abgeschnitten wird.
    :return: null
    """
    p = '%.{k}f'.format(k=precison)
    ps = []
    for arguments in arg:
        ps.append(p)
    try:
        np.savetxt(
           filename,
           np.c_[arg],
           fmt=ps,
           delimiter=',',
           newline='\n',
           # footer='end of file',
           # comments='# ',
           # header='X , MW'
        )
    except TypeError:
        print("TypeError occured")
        for arguments in arg:
            print(arguments)
